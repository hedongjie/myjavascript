<!DOCTYPE HTML>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
    <script type="text/javascript">
 /*       var Cat = {
            name: '',
            color: ''
        }*/
/*function Cat(name, color) {
    return {//返回一个对象
        name: name,
        color: color
    }
}
var cat1 = Cat('大毛','黄色');
alert(cat1.name);*/
/*
构造函数模式
为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。
所谓"构造函数"，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上
每个对象的实例都会包含有一个constructor，constructor属性，指向它们的构造函数
Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系
构造函数的问题就是每次生成实例都会都会重复方法和属性，多占内存
Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承
isPrototypeOf()
这个方法用来判断，某个proptotype对象和某个实例之间的关系
hasOwnProperty()
每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。

 */
/*function Cat(name,color) {
    this.name = name;//this指向对象，也就是Cat的实例
    this.color = color;
}
var cat2 = new Cat('alanerzhao','red');
alert(cat2.constructor == Cat);//说明cat2是Cat的实例对象
alert(cat2 instanceof Cat);

alert(cat2.name);*/
    //原型模式
    function Cat(name,color) {
        this.name = name;
        this.color = color;
    }
Cat.prototype.type = 'alanerzhao';
Cat.prototype.eat = '吃饭';
var cat1 = new Cat('alert','red');
//alert(Cat.prototype.isPrototypeOf(cat1));
alert(cat1.hasOwnProperty('eat'));//eat是原型的属性
function Foo(){
this.value = 52;
}
Foo.prototype = {
    method: function() {};
}

    </script>
</body>
</html>
